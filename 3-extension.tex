%TEX root = main.tex
\section{Existential extension of LHC}

\subsection{New operator}

The main point of the extension is to add an object to the language complementary to the $\mathbf{wp}_{\forall}$ from the original model.

This object is defined as such :

\begin{definition}[Weakest existential precondition]
$\WPE{\m{t}}{Q} := \lambda \m{s}. \E \m{s'} \m{v}. \bigstep {\m{t}}{\m{s}} {\m{v}} {\m{s'}} \land Q(\m{v})$
\end{definition}

This object behaves in the same way as $\mathbf{wp}_{\forall}$ for most of the rules previously described. Those rules are written down for completeness. Most of the rules can be mirrored as is (just switching a $\mathbf{wp}_{\forall}$ for a $\mathbf{wp}_{\exists}$), but some needs more changes.

\textsc{wp$_{exists}$-exists} mirrors \textsc{wp$_{\forall}$-all}, but uses existential quantifiers instead of universal ones. Without much surprise, $\mathbf{wp}_{\exists}$ works better with existentials. \textsc{wp$_{\exists}$-while$_I$} was modified to take into account the necessity of projectability for $\mathbf{wp}_{\exists}$ statements.

\begin{mathfig}{\small}
    \begin{proofrules}
        \input{rules/wpE-cons.tex}

        \input{rules/wpE-exists.tex}

        \input{rules/wpE-frame.tex}

        \input{rules/wpE-impl-r.tex}

        \input{rules/wpE-subst.tex}

        \input{rules/wpE-idx.tex}

        \input{rules/wpE-seq.tex}

        \input{rules/wpE-assign.tex}

        \input{rules/wpE-if.tex}

        \input{rules/wpE-while.tex}

        \input{rules/wpE-nest.tex}

        \input{rules/wpE-conj.tex}

        \input{rules/wpE-idx-pass.tex}

        \input{rules/wpE-idx-swap.tex}

        \input{rules/wpE-idx-merge.tex}

        \input{rules/wpE-idx-post.tex}
    \end{proofrules}
    \caption{Rules for $\mathbf{wp}_{\exists}$ mirrored on $\mathbf{wp}_{\forall}$}
\end{mathfig}

An interesting point is that predicates that couldn't be defined in the original theory using the base langugage, and thus needed to be explicitly defined to be used, can now be defined using this new $\mathbf{wp}_{\exists}$ object.

\begin{eqnarray*}
    \proj(t) &:=& \WPE{\m{t}}{\True} \\
    t_1 \semleq t_2 &:=& \V s(1)=s(2) |- \WPU{[1: t_1]}{\WPE{[2: t_2]}{v(1) = v(2) \land s(1) = s(2)}}
\end{eqnarray*}

Thus certain rules from LHC can now be rewritten by combining $\mathbf{wp}_{\forall}$ and $\mathbf{wp}_{\exists}$

\begin{mathfig}{\small}
    \begin{proofrules}
        \input{rules/wp-refine.tex}

        \input{rules/wp-proj.tex}
    \end{proofrules}
    \caption{Rules rewritten using $\mathbf{wp}_{\exists}$}
\end{mathfig}

\begin{mathfig}{\small}
    \begin{proofrules}
        \input{rules/wp-triv.tex}

        \input{rules/proj-elim}
    \end{proofrules}
    \caption{Rules combining $\mathbf{wp}_{\forall}$ and $\mathbf{wp}_{\exists}$}
\end{mathfig}

\subsection{Relation to $\mathbf{wp}_{\forall}$}

With the use of $\mathbf{wp}_{\exists}$, one can write an interesting property:
\begin{eqnarray*}
    PDet(t) &:=& \WPE {\m{t}} Q \lequiv \WPU {\m{t}} Q
\end{eqnarray*}

This property is in fact equivalent to $Det(t) \land \proj(t)$, as is shown below.

\begin{lemma}[$Det(t)\land\proj(t) \iff PDet(t)$]
\end{lemma} 
\begin{proof}
    If $\m{t}$ is deterministic and has a terminating trace, then any terminating trace gives the same output, given the same input. Thus, if there exists a trace that satisfies some property $Q$, then any trace will satisfy the same property. Therefore, we have the direct statement.

    For the reciprocal, we will separate the proof of $PDet(t) \implies Det(t)\land\proj(t)$ in two separate derivations. First off, $PDet(t) \implies \proj(t)$.

    \begin{prooftree}
        \AxiomC{}
        \LeftLabel{\scriptsize\textsf{wp$_{\forall}$-triv}}
        \UnaryInfC{$\V |- \WPU {\m{t}}{\True}$}
        \AxiomC{}
        \RightLabel{\scriptsize{$PDet(t)$}}
        \UnaryInfC{$\V \WPU {\m{t}}{\True} |- \WPE {\m{t}}{\True}$}
        \BinaryInfC{$\V |- \WPE {\m{t}}{\True}$}
    \end{prooftree}

    Next, $PDet(t) \implies Det(t)$.
    \begin{scprooftree}{0.9}
        \AxiomC{$\V \pv{x}(\I1)=\pv{x}(\I2) |- \WPE {\m<\I1: t, \I2: t>}{\pv{x}(\I1)=\pv{x}(\I2)}$}
        \AxiomC{}
        \RightLabel{\scriptsize{$PDet(t)$}}
        \UnaryInfC{$\V \WPE {\m<\I1: t, \I2: t>}{\pv{x}(\I1)=\pv{x}(\I2)} |- \WPU {\m<\I1: t, \I2: t>}{\pv{x}(\I1)=\pv{x}(\I2)}$}
        \BinaryInfC{$\V \pv{x}(\I1)=\pv{x}(\I2) |- \WPU {\m<\I1: t,\I2: t>}{\pv{x}(\I1)=\pv{x}(\I2)}$}
    \end{scprooftree}

    The left-side assumption is proved the following way: given that both terms receive the same input, if we chose the same trace to execute in both terms, we then get the same output (i.e every term is "deterministic" in the context of $\mathbf{wp}_{\exists}$).

    Thus we get an equivalence between $PDet(t)$ and $Det(t)\land\proj(t)$
\end{proof}

\subsection{Swap rule and lockstep rules}

As stated before, $\mathbf{wp}_{\exists}$ behaves more or less the same way as $\mathbf{wp}_{\forall}$, and thus, proofs using it exclusively are very similar in form. Most of the capabilities of this model appears when combining both operators. However, one would need rules to deal with hyperproperties combining the two $\mathbf{wp}$.

\begin{mathfig}{\small}
    \begin{proofrules}        
        \input{rules/wp-swap.tex}

        \input{rules/wp-swap-local.tex}
    \end{proofrules}
    \caption{Swap rules}
\end{mathfig}

A pair of such rules are \textsc{wp-swap} and \textsc{wp-swap-local}. A special attention will be given to the first one, because it allows us to derive most lockstep rules combining $\mathbf{wp}_{\exists}$ and $\mathbf{wp}_{\forall}$.

Let's consider two examples: \textsc{wp-if} and \textsc{wp-seq}.

\resizebox{0.8\width}{!}{
\begin{proofrules}
    \input{rules/wp-seq.tex}

    \input{rules/wp-if.tex}
\end{proofrules}
}

\bigskip

We can derive both rules from \textsc{wp-swap}, as follows:

\bigskip

\begin{prooftree}
    \AxiomC{$\WPU {\m[i: t_i | i \in I]}{\WPE {\m[j: u_j | j \in J]}{\WPU {\m[i: t'_i | i \in I]}{\WPE {\m[j: u'_j | j \in J]}{Q}}}}$}
    \UnaryInfC{$\WPU {\m[i: t_i | i \in I]}{\WPU {\m[j: t'_i | i \in I]}{\WPE {\m[i: u_j | j \in J]}{\WPE {\m[j: u'_j | j \in J]}{Q}}}}$}
    \UnaryInfC{$\WPU {\m[i: t_i; t'_i| i \in I]}{\WPE {\m[j: u_j; u'_j | j \in J]}{Q}}$}
\end{prooftree}

\bigskip

\begin{scprooftree}{0.8}
    \AxiomC{$\WPU {\m[i: g_i | i \in I]}*
    {\fun b. \WPE {\m[j: g'_j | j \in J]}*
    {\fun b'. \WPU {
        \begin{pmatrix*}[l]
        {\m[i: t_i | i\in I, \m{b}(i) \neq 0]}{\m.}\\
        {\m[i: t'_i | i\in I, \m{b}(i) = 0]}
        \end{pmatrix*}
        }*{\WPE {
        \begin{pmatrix*}[l]
        {\m[i: u_j | j\in I, \m{b}'(i) \neq 0]}{\m.}\\
        {\m[i: u'_j | j\in I, \m{b}'(i) = 0]}
        \end{pmatrix*}           
        }{Q}}
    }}$}
    \UnaryInfC{$\WPU {\m[i: g_i | i \in I]}*
    {\fun b. \WPU {
        \begin{pmatrix*}[l]
        {\m[i: t_i | i\in I, \m{b}(i) \neq 0]}{\m.}\\
        {\m[i: t'_i | i\in I, \m{b}(i) = 0]}
        \end{pmatrix*}}*
        {\WPE {\m[j: g'_j | j \in J]
        }*{\fun b'. \WPE {
        \begin{pmatrix*}[l]
        {\m[i: u_j | j\in I, \m{b}'(i) \neq 0]}{\m.}\\
        {\m[i: u'_j | j\in I, \m{b}'(i) = 0]}
        \end{pmatrix*}           
        }{Q}}
    }}$}
    \UnaryInfC{$\WPU {\m[i: \code{if}\ g_i\ \code{then}\ t_i\ \code{else}\  t'_i| i \in I]}{\WPE {\m[j: \code{if}\ g'_j\ \code{then}\ u_j\ \code{else}\ u'_j | j \in J]}{Q}}$}
\end{scprooftree}

In both cases, we simply "unfold" the terms using the corresponding $\mathbf{wp}_{\forall}$ and $\mathbf{wp}_{\exists}$ rules, and then a number \textsc{wp-swap} to complete the proof.

\subsection{The while rule}

There, of course, exists a rule for \code{while} statements of the same type than for \code{if} and sequential statements.

\begin{proofrules}
    \input{rules/wp-while.tex}
\end{proofrules}

\bigskip

However, the proof strategy used previously doesn't work for this rule. It comes down to the fact that if we simply unfold \code{while} ($\code{while}\ g\ \code{do}\ t \implies \code{if}\ g\ \code{then}\ \code{skip}\ \code{else}\ \code{while}\ g\ \code{do}\ t$), we can't get a terminating proof, because we get the conclusion as a premisse. The main issue is that we're missing a way to do induction proofs on the length of the loop inside the logic.

Thankfully, there may be a way to deal with this issue, using a certain encoding of \code{while}. We will add to construct to the language: \code{assume} and *. Their semantic value can be defined as follows, with $t^n$ a notation for a sequence of $n$ terms $t$.

\begin{proofrules}
    \infer*{\E v\ne 0. \bigstep g s v {s'}}{\bigstep {\code{assume}(g)} s 1 {s'}}

    \infer*{\E n. \bigstep {t^n} s v {s'}}{\bigstep {t^*} s v {s'}}
\end{proofrules}

From this, we can encode $\code{while}\ g\ \code{do}\ t \is (\code{assume}(g); t)^*;\code{assume}(\lnot g)$. Thus, if we have rules for \code{assume} and *, we can derive the rule for \code{while}. The question is, what did we gain from this encoding ? The short answer is that \code{assume} and * have similar $\mathbf{wp}_{\forall}-\mathbf{wp}_{\exists}$ rules with \code{if} and sequences. The long answer is the following.

We can derive four rules for \code{assume} and * (described in Fig.10). From those rules, one can derive rules of the same form as the \code{if} one:

\begin{proofrules}
    \input{rules/wp-assume.tex}

    \input{rules/wp-star.tex}
\end{proofrules}

\begin{mathfig}
    \begin{proofrules}
        \input{rules/wpU-assume.tex}

        \input{rules/wpE-assume.tex}

        \input{rules/wpU-star.tex}

        \input{rules/wpE-star.tex}
    \end{proofrules}
    \caption{Rules for \code{assume} and *}
\end{mathfig}

They are derived thusly:

\begin{prooftree}
    \AxiomC{$\WPU {\m[i: g_i | i \in I]}
            {\fun \m{v}. \WPE {\m[j: g'_j | j \in J]} {\fun \m{w}. Q(\m{v}\cdot\m{w}) \land\m{w} \ne 0}}$}
    \UnaryInfC{$\WPU {\m[i: \code{assume}(g_i) | i \in I]}
                {\WPE {\m[j: g'_j | j \in J]} {\fun \m{w}. Q(1\cdot\m{w}) \land\m{w} \ne 0}}$}
    \UnaryInfC{$\WPU {\m[i: \code{assume}(g_i) | i \in I]}
                {\WPE {\m[j: \code{assume}(g'_j) | j \in J]} {\fun \m{w}. Q(1 \cdot \m{w})}}$}
\end{prooftree}

\begin{scprooftree}{0.75}
    \AxiomC{$\V P |- \WPU {\m[i: t_i | i \in I]}
            {\WPE {\m[j: t'_j | j \in J]} P}$}
    \AxiomC{}
    \UnaryInfC{$\A n. \V \WPU {\m[i: t_i^n | i \in I]}
            {\WPE {\m[j: {t'_j}^n | j \in J]} P}
            |- \WPU {\m[i: t_i^n | i \in I]}
            {\WPE {\m[j: {t'_j}^n | j \in J]} P}$}
    \BinaryInfC{$\A n. \V P, \WPU {\m[i: t_i^n | i \in I]}
                {\WPE {\m[j: {t'_j}^n | j \in J]} P}
                |- \WPU {\m[i: t_i | i \in I]}
                {\WPE {\m[j: t'_j | j \in J]}
                {\WPU {\m[i: t_i^n | i \in I]}
                {\WPE {\m[j: {t'_j}^n | j \in J]} P}}}$}
    \UnaryInfC{$\A n. \V P, \WPU {\m[i: t_i^n | i \in I]}
                {\WPE {\m[j: {t'_j}^n | j \in J]} P}
                |- \WPU {\m[i: t_i^{n+1} | i \in I]}
                {\WPE {\m[j: {t'_j}^{n+1} | j \in J]} P}$}
    \UnaryInfC{$\A n. \V P, \WPU {\m[i: t_i^n | i \in I]}
                {\WPE {\m[j: {t'_j}^* | j \in J]} P}
                |- \WPU {\m[i: t_i^{n+1} | i \in I]}
                {\WPE {\m[j: {t'_j}^* | j \in J]} P}$}
    \UnaryInfC{$\V P |- \WPU {\m[i: t_i^* | i \in I]}
                {\WPE {\m[j: {t'_j}^* | j \in J]} P}$}
\end{scprooftree}

