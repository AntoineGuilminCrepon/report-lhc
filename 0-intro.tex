\section{Introduction}

Many properties about programs are not properties on one specific trace of a program, but rather of several traces from multiple programs. For example, non-determinism cannot be formally specified as a property on a single execution, because proving it requires to distinguish at least two traces giving back differents outputs from the same input. Those "multi-traces" properties have been formally studied by \citet{ClarksonS08}, who coined the term \emph{hyperproperties}.
More formally, those hyperproperties are of the form:
\(
    Q_1 (s_1, s'_1) \in \sem{t_1},
    \dots
    Q_n (s_n, s'_n) \in \sem{t_n},
    \phi(s_1, s'_1, \dots, s_n, s'_n)
\)
where $\sem{t}$ is the \emph{semantic} of $t$, i.e the set of input/output states of the traces of $t$, and the $Q_i$ are existential or universal quantifiers. Examples of hyperproperties are refinement ($n = 2, (Q_1, Q_2) = (\forall, \exists)$), minimum ($n = 2, (Q_1, Q_2) = (\exists, \forall)$) or transitivity ($n = 3, (Q_1, Q_2, Q_3) = (\forall, \forall, \forall)$).

A na√Øve way of proving those hyperproperties whould be to compute $\sem{t}$ for every $t$ we need, and then evaluate $\phi$ using the results. However, this approach requires us to prove the functional correctness of $t$, which is stronger than what is needed to prove $\phi$.

To solve this issue, it is easier to reason directly on judgements we will now call \emph{hyper-triples}, which are an extension of Hoare triples, that take multiple programs as arguments. Relational logics have already been built using those hyper-triples in \cite{Yang07, SousaD16, Benton04, BartheCK16}. 